/**
 * Core Philosophy: This ruleset implements a strict Role-Based Access Control (RBAC) model.
 * A dedicated `/roles_admin` collection serves as the single source of truth for identifying
 * administrative users. Only these designated admins are permitted to create, manage, and
 * view content like posts and categories. Standard users have very limited permissions,
 * primarily allowing them to create their own user profile.
 *
 * Data Structure: The data is organized into several top-level collections: `/users`,
 * `/roles_admin`, `/categories`, and `/posts`. This separation ensures
 * that data with different security requirements (e.g., admin-only content vs. publicly
 * writeable analytics) are isolated from each other.
 *
 * Key Security Decisions:
 * - Admin Role Management: The `/roles_admin` collection is the cornerstone of the security
 *   model. The existence of a document in this collection grants a user admin privileges.
 *   To prevent unauthorized privilege escalation, this collection is made completely
 *   inaccessible from the client-side. Admin roles must be managed via a trusted
 *   server environment or the Firebase Console.
 * - Content Access: All primary content (`/posts`, `/categories`)
 *   is private and accessible only to admins for all operations (read and write). There
 *   is no public read access.
 * - User Profile Security: Users are allowed to create their own profile document upon
 *   signing up and can read their own data. However, only admins are permitted to update
 *   or delete user profiles.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the given userId.
     * Used to verify resource ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user has an admin role.
     * Admin status is determined by the existence of a document in the
     * /roles_admin collection corresponding to the user's UID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     * This prevents operations on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description A special collection used by the client to verify if a user has admin
     *              privileges without exposing any data. The client attempts to read a
     *              document from this collection; if the read succeeds, the user is an admin.
     *              The read will fail for non-admins due to security rules.
     * @path /admin_check/{docId}
     * @allow (get) An admin user successfully performs a 'get' to verify their status.
     * @deny (get) A non-admin user's 'get' request is denied.
     * @deny (any) All other operations (list, write) are denied for all users.
     * @principle Provides a secure client-side mechanism to check for server-side roles without exposing role data.
     */
    match /admin_check/{docId} {
      allow get: if isAdmin();
      allow list, write: if false;
    }

    /**
     * @description Manages administrative user profiles. Users can create and read their own
     *              profile. Admins can read, update, and delete any profile.
     * @path /users/{userId}
     * @allow (create) A new authenticated user 'user123' creates their own profile document at `/users/user123`.
     * @allow (get) User 'user123' reads their own profile at `/users/user123`.
     * @allow (update) An admin user updates the profile for 'user123'.
     * @deny (update) User 'user123' attempts to update their own profile.
     * @deny (get) User 'user456' attempts to read the profile of 'user123'.
     * @principle Enforces self-creation, read-only ownership for users, and role-based access for all write modifications.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Defines admin roles via document existence. This collection is locked down
     *              from all client-side access to prevent tampering. Roles must be assigned
     *              through the Firebase Console or a trusted backend server.
     * @path /roles_admin/{userId}
     * @allow (any) No client operation is ever permitted.
     * @deny (any) Any user, including an admin, attempting to read or write this collection.
     * @principle Secures role management by preventing any and all client-side modifications or reads.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores categories for blog posts. Full read and write access is restricted
     *              to administrative users only.
     * @path /categories/{categoryId}
     * @allow (create) An admin user creates a new category document.
     * @allow (list) An admin user lists all available categories.
     * @deny (get) A non-admin user attempts to read a category.
     * @deny (create) A non-admin user attempts to create a new category.
     * @principle Enforces strict role-based access control for content taxonomy.
     */
    match /categories/{categoryId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores blog posts. Public users can read published posts. Admins have full
     *              CRUD access. Ensures that the post's authorId is correctly set on creation
     *              and cannot be changed.
     * @path /posts/{postId}
     * @allow (get) Any user reads a published post. An admin reads any post.
     * @allow (list) Any user can query for published posts. Admins can query for all posts.
     * @deny (create) A non-admin user attempts to create a post.
     * @principle Public read access for published content, role-based access for mutations.
     */
    match /posts/{postId} {
      allow get: if resource.data.status == 'published' || isAdmin();
      allow list: if true;
      allow create: if isAdmin() && request.resource.data.authorId == request.auth.uid;
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.authorId == resource.data.authorId;
      allow delete: if isAdmin() && isExistingDoc();
    }
  }
}
