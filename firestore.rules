/**
 * Core Philosophy: This ruleset implements a strict Role-Based Access Control (RBAC) model.
 * A dedicated `/roles_admin` collection serves as the single source of truth for identifying
 * administrative users. Only these designated admins are permitted to create, manage, and
 * view content like posts and categories. Standard users have very limited permissions,
 * primarily allowing them to create their own user profile.
 *
 * Data Structure: The data is organized into several top-level collections: `/users`,
 * `/roles_admin`, `/categories`, and `/posts`. This separation ensures
 * that data with different security requirements (e.g., admin-only content vs. publicly
 * writeable analytics) are isolated from each other.
 *
 * Key Security Decisions:
 * - Admin Role Management: The `/roles_admin` collection is the cornerstone of the security
 *   model. The existence of a document in this collection grants a user admin privileges.
 *   To prevent unauthorized privilege escalation, this collection is made completely
 *   inaccessible from the client-side. Admin roles must be managed via a trusted
 *   server environment or the Firebase Console.
 * - Content Access: All primary content (`/posts`, `/categories`)
 *   is private and accessible only to admins for all operations (read and write), with the
 *   exception of published posts which are publicaly readable.
 * - User Profile Security: Users are allowed to create their own profile document upon
 *   signing up and can read their own data. However, only admins are permitted to update
 *   or delete user profiles.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the given userId.
     * Used to verify resource ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user has an admin role.
     * Admin status is determined by the user's role field.
     */
    function isAdmin() {
      return isSignedIn() && userRole() == 'admin';
    }

    /**
     * Reads the role value from the user's profile.
     */
    function userRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isWriter() {
      return isSignedIn() && userRole() == 'writer';
    }

    function isEditor() {
      return isSignedIn() && userRole() == 'editor';
    }

    function isAdminOrEditor() {
      return isAdmin() || isEditor();
    }


    /**
     * Verifies that a document exists before an update or delete operation.
     * This prevents operations on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages administrative user profiles. Users can create and read their own
     *              profile. Admins can read, update, and delete any profile.
     * @path /users/{userId}
     * @allow (create) A new authenticated user 'user123' creates their own profile document at `/users/user123`.
     * @allow (get) User 'user123' reads their own profile at `/users/user123`.
     * @allow (update) An admin user updates the profile for 'user123'.
     * @deny (update) User 'user123' attempts to update their own profile.
     * @deny (get) User 'user456' attempts to read the profile of 'user123'.
     * @principle Enforces self-creation, read-only ownership for users, and role-based access for all write modifications.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() || (isOwner(userId) && request.resource.data.id == userId);
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && isExistingDoc();
    }

    // /roles_admin no longer used; role is stored on user profiles.

    /**
     * @description Stores categories for blog posts. Full read and write access is restricted
     *              to administrative users only.
     * @path /categories/{categoryId}
     * @allow (create) An admin user creates a new category document.
     * @allow (list) An admin user lists all available categories.
     * @deny (get) A non-admin user attempts to read a category.
     * @deny (create) A non-admin user attempts to create a new category.
     * @principle Enforces strict role-based access control for content taxonomy.
     */
    match /categories/{categoryId} {
      // Any signed-in user can read categories (needed for post creation).
      allow get, list: if isSignedIn();
      // Only editors/admins manage categories.
      allow create: if isAdminOrEditor();
      allow update: if isAdminOrEditor() && isExistingDoc();
      allow delete: if isAdminOrEditor() && isExistingDoc();
    }

    /**
     * @description Stores blog posts. Public users can read published posts. Admins have full
     *              CRUD access. Ensures that the post's authorId is correctly set on creation
     *              and cannot be changed.
     * @path /posts/{postId}
     * @allow (get) Any user reads a published post. An admin reads any post.
     * @allow (list) Any user can query for published posts. Admins can query for all posts.
     * @deny (create) A non-admin user attempts to create a post.
     * @principle Public read access for published content, role-based access for mutations.
     */
    match /posts/{postId} {
      // --- Read Access ---
      // Admins and editors can read any post.
      allow read: if isAdminOrEditor();
      // Any user can read published posts.
      allow read: if resource.data.status == 'published';
      // Any signed-in user can read their own posts (including drafts).
      allow read: if isSignedIn() && resource.data.authorId == request.auth.uid;


      // --- Create Access ---
      // Admins and editors can create drafts or publish immediately.
      allow create: if isAdminOrEditor() &&
        request.resource.data.authorId == request.auth.uid &&
        (request.resource.data.status == 'draft' || request.resource.data.status == 'published');
      // Writers can only create drafts for themselves.
      allow create: if isWriter() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.status == 'draft';

      // --- Update Access ---
      // Admins and editors can update any post, but cannot change authorId.
      allow update: if isAdminOrEditor() &&
        request.resource.data.authorId == resource.data.authorId;
      // Writers can only update their own drafts and keep status as draft.
      allow update: if isWriter() &&
        request.resource.data.authorId == resource.data.authorId &&
        resource.data.authorId == request.auth.uid &&
        resource.data.status == 'draft' &&
        request.resource.data.status == 'draft';

      // --- Delete Access ---
      allow delete: if isAdmin();
    }

    /**
     * @description Tracks per-post view statistics and per-IP view entries.
     * @path /post_views/{postId}
     * @allow (read) Admins can read stats.
     * @allow (create/update) Public can increment stats (best-effort analytics).
     */
    match /post_views/{postId} {
      allow get, list: if isAdminOrEditor() || (isSignedIn() && get(/databases/$(database)/documents/posts/$(postId)).data.authorId == request.auth.uid);
      allow create, update: if
        request.resource.data.keys().hasOnly(['totalViews', 'uniqueViews', 'updatedAt']) &&
        request.resource.data.totalViews is int &&
        ( !('uniqueViews' in request.resource.data) || request.resource.data.uniqueViews is int );

      match /ips/{ipId} {
        allow get, list: if isAdminOrEditor() || (isSignedIn() && get(/databases/$(database)/documents/posts/$(postId)).data.authorId == request.auth.uid);
        allow create, update: if
          request.resource.data.keys().hasOnly(['createdAt', 'lastSeenAt']);
      }
    }
  }
}
