/**
 * Core Philosophy: This ruleset implements a strict Role-Based Access Control (RBAC) model.
 * A dedicated `/roles_admin` collection serves as the single source of truth for identifying
 * administrative users. Only these designated admins are permitted to create, manage, and
 * view content like posts and categories. Standard users have very limited permissions,
 * primarily allowing them to create their own user profile and to write click-tracking
 * events.
 *
 * Data Structure: The data is organized into several top-level collections: `/users`,
 * `/roles_admin`, `/categories`, `/posts`, and `/linkClicks`. This separation ensures
 * that data with different security requirements (e.g., admin-only content vs. publicly
 * writeable analytics) are isolated from each other. Posts can contain a subcollection
 * of `/affiliateLinks`.
 *
 * Key Security Decisions:
 * - Admin Role Management: The `/roles_admin` collection is the cornerstone of the security
 *   model. The existence of a document in this collection grants a user admin privileges.
 *   To prevent unauthorized privilege escalation, this collection is made completely
 *   inaccessible from the client-side. Admin roles must be managed via a trusted
 *   server environment or the Firebase Console.
 * - Content Access: All primary content (`/posts`, `/categories`, and their subcollections)
 *   is private and accessible only to admins for all operations (read and write). There
 *   is no public read access.
 * - "Dropbox" Collection: The `/linkClicks` collection is configured as a "dropbox". It is
 *   publicly writeable by anyone (including anonymous users) to allow for analytics
 *   tracking, but it is read-only for admins to prevent data tampering and ensure privacy.
 * - User Profile Security: Users are allowed to create their own profile document upon
 *   signing up and can read their own data. However, only admins are permitted to update
 *   or delete user profiles.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the given userId.
     * Used to verify resource ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user has an admin role.
     * Admin status is determined by the existence of a document in the
     * /roles_admin collection corresponding to the user's UID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     * This prevents operations on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description A special collection used by the client to verify if a user has admin
     *              privileges without exposing any data. The client attempts to read a
     *              document from this collection; if the read succeeds, the user is an admin.
     *              The read will fail for non-admins due to security rules.
     * @path /admin_check/{docId}
     * @allow (get) An admin user successfully performs a 'get' to verify their status.
     * @deny (get) A non-admin user's 'get' request is denied.
     * @deny (any) All other operations (list, write) are denied for all users.
     * @principle Provides a secure client-side mechanism to check for server-side roles without exposing role data.
     */
    match /admin_check/{docId} {
      allow get: if isAdmin();
      allow list, write: if false;
    }

    /**
     * @description Manages administrative user profiles. Users can create and read their own
     *              profile. Admins can read, update, and delete any profile.
     * @path /users/{userId}
     * @allow (create) A new authenticated user 'user123' creates their own profile document at `/users/user123`.
     * @allow (get) User 'user123' reads their own profile at `/users/user123`.
     * @allow (update) An admin user updates the profile for 'user123'.
     * @deny (update) User 'user123' attempts to update their own profile.
     * @deny (get) User 'user456' attempts to read the profile of 'user123'.
     * @principle Enforces self-creation, read-only ownership for users, and role-based access for all write modifications.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Defines admin roles via document existence. This collection is locked down
     *              from all client-side access to prevent tampering. Roles must be assigned
     *              through the Firebase Console or a trusted backend server.
     * @path /roles_admin/{userId}
     * @allow (any) No client operation is ever permitted.
     * @deny (any) Any user, including an admin, attempting to read or write this collection.
     * @principle Secures role management by preventing any and all client-side modifications or reads.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores categories for blog posts. Full read and write access is restricted
     *              to administrative users only.
     * @path /categories/{categoryId}
     * @allow (create) An admin user creates a new category document.
     * @allow (list) An admin user lists all available categories.
     * @deny (get) A non-admin user attempts to read a category.
     * @deny (create) A non-admin user attempts to create a new category.
     * @principle Enforces strict role-based access control for content taxonomy.
     */
    match /categories/{categoryId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores blog posts. Full read and write access is restricted to administrative
     *              users. Ensures that the post's authorId is correctly set on creation
     *              and cannot be changed.
     * @path /posts/{postId}
     * @allow (create) An admin with UID 'admin123' creates a post where the 'authorId' field is also 'admin123'.
     * @allow (get) An admin user reads any post.
     * @deny (list) A non-admin user attempts to list posts.
     * @deny (create) An admin user tries to create a post and assign it to a different author.
     * @principle Enforces role-based access while ensuring relational integrity of authorship.
     */
    match /posts/{postId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.authorId == request.auth.uid;
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.authorId == resource.data.authorId;
      allow delete: if isAdmin() && isExistingDoc();

      /**
       * @description Stores affiliate links associated with a blog post. Access is restricted
       *              to administrative users only.
       * @path /posts/{postId}/affiliateLinks/{affiliateLinkId}
       * @allow (create) An admin user adds a new affiliate link to an existing post.
       * @deny (get) A non-admin user attempts to read an affiliate link.
       * @principle Inherits the parent document's role-based security model for subcollections.
       */
      match /affiliateLinks/{affiliateLinkId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin() && request.resource.data.postId == postId;
        allow update: if isAdmin() && isExistingDoc() && request.resource.data.postId == resource.data.postId;
        allow delete: if isAdmin() && isExistingDoc();
      }
    }

    /**
     * @description Stores click events for affiliate links. This collection is publicly
     *              writeable to allow tracking from any client, but read, update, and delete
     *              operations are restricted to admins for data analysis and integrity.
     * @path /linkClicks/{linkClickId}
     * @allow (create) Any user, including anonymous users, creates a new link click document.
     * @deny (get) A non-admin user attempts to read a click event.
     * @deny (update) Any non-admin user attempts to modify an existing click event.
     * @principle Implements a secure "dropbox" pattern where data can be submitted publicly but not viewed or altered.
     */
    match /linkClicks/{linkClickId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if true;
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }
  }
}
